# Занятие 6

## Домашнее задание

За каждое задание начисляются баллы.

### Общее ТЗ

1. Пулл-реквест с ДЗ вмержен в ветку `main` до 18.12.2022.
2. В папке `hw/<ваше имя и фамилия>/` есть питон-пакет `lesson06` (далее — _рабочий пакет_).
3. В рабочем пакете есть питон-модуль `tasks.py` (далее - _модуль решений_).
4. Функции-решения задач урока написаны в модуле решения в любом порядке.
5. Функции-решения покрыты тестами в отдельном модуле в рабочем пакете: `tasks_test.py` (далее — _модуль с тестами_).
6. Функции-тесты написаны в модуле с тестами в любом порядке.

### ТЗ по задачам

---

#### 1. Задача про начало и конец упорядоченной коллекции (+1)

Существует функция с названием `task_01_boundary`.

Функция принимает параметры:

- `sequence`: любая упорядоченная коллекция;

Функция возвращает результат:

- кортеж из двух элементов: начальным и конечным из аргумента.

Для пустого аргумента поведение неопределено.

Пример:

```python
assert task_01_boundary("ab") == ("a", "b")
```

---

#### 2. Задача про размножение коллекции (+1)

Существует функция с названием `task_02_expand`.

Функция принимает параметры:

- `sequence`: любая упорядоченная коллекция;

В аргументе первым элементом будет целое число. Для коллекции,
в которой первым элементом будет не целое число, результат неопределён.

Функция возвращает результат:

- N копий аргумента без первого элемента. N = первый элемент аргумента.
  Тип выходной коллекции совпадает с типом входной.

Пример:

```python
assert task_02_expand([2, 3, 4]) == [3, 4, 3, 4]
```

---

#### 3. Задача про расстояние Хэмминга (+1)

Существует функция с названием `task_03_hdist`.

Функция принимает параметры:

- `seq1`: любая упорядоченная коллекция;
- `seq2`: любая упорядоченная коллекция;

Функция возвращает целое число:

- [расстояние Хэмминга](https://ru.m.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%A5%D1%8D%D0%BC%D0%BC%D0%B8%D0%BD%D0%B3%D0%B0) между двумя аргументами;


Если для позиции в аргументах стоят разные элементы, то расстояние увеличивается на 1.
Если коллекции разной длины, то разница учитывается: каждый "лишний" элемент добавляет +1 к расстоянию.

Пример:

```python
assert task_03_hdist("aaa", "aab") == 1
assert task_03_hdist("aaa", "aba") == 1
assert task_03_hdist("aaa", "baa") == 1
assert task_03_hdist("", "baa") == 3
```

---

#### 4. Задача про города (+3)

Существует функция с названием `task_04_cities`.

Функция возвращает информацию о расстоянии до всех городов
от переданного города.

Функция принимает параметр:
- `city`: строка, название города;

Функция возвращает значение:
- словарь: ключ — название города, значение — расстояние до него в километрах;

Для неизвестных городов поведение не определено.

Города и их координаты возьмите в `hw.alexander_sidorov.helpers.CITIES`.

Расстояние считайте в километрах.

Расстояние вычисляйте в [евклидовой метрике](https://en.m.wikipedia.org/wiki/Euclidean_distance), без учета кривизны Земли.

Считайте, что 1º при движении по горизонтали (между параллелями) = 65 км.

Считайте, что 1º при движении по вертикали (между широтами) = 111 км.

Так же в помощь [теорема Пифагора](https://ru.m.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%9F%D0%B8%D1%84%D0%B0%D0%B3%D0%BE%D1%80%D0%B0).

Пример:

```python
distances = task_04_cities("Минск")
km = distances["Жодино"]
assert int(km) == 54
```

_Подсказка_: если расчёт расстояния выделить в отдельную функцию,
то это упростит решение и этой задачи, и задачи №5.

---

#### 5. Задача про маршруты (+4)

Существует функция с названием `task_05_route`.

Функция возвращает информацию о длине маршрута.
Маршрут передаётся в форме последовательности названий городов.

Функция принимает параметр:
- `route`: упорядоченная коллекция названий городов;

Функция возвращает значение:
- вещественное число, длина маршрута в километрах;

Неизвестные города игнорируйте.

Города и их координаты возьмите в `hw.alexander_sidorov.helpers.CITIES`.

Расстояние считайте в километрах.

Расстояние вычисляйте в [евклидовой метрике](https://en.m.wikipedia.org/wiki/Euclidean_distance), без учета кривизны Земли.

Считайте, что 1º при движении по горизонтали (между параллелями) = 65 км.

Считайте, что 1º при движении по вертикали (между широтами) = 111 км.

Так же в помощь [теорема Пифагора](https://ru.m.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%9F%D0%B8%D1%84%D0%B0%D0%B3%D0%BE%D1%80%D0%B0).

Пример:

```python
km = task_05_route(("Минск", "Минск", "Жодино", "Жодино", "Минск"))
assert int(km) == 108
```
